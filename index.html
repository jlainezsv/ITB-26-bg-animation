<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ITB Room Experience</title>

  <style>
    html{background: #0f1316;}
    
    body {
      height: 100%;
      margin: 0;
      
      overflow-x: hidden;
    }

    #container {
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
    }

    main {
      position: relative;
      z-index: 2;
      padding: 48px 6vw;
      min-height: 200vh;
      color: #fff;
      font-family: sans-serif;
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <div style="height: 8000px;"></div>

  <!-- =========================================================
       THREE.JS — IMPORTS CDN (sin dependencias locales)
       ========================================================= -->
  <script type="module">

import * as THREE from "https://esm.sh/three@0.158.0";
import { OrbitControls } from "https://esm.sh/three@0.158.0/examples/jsm/controls/OrbitControls.js";
import { EffectComposer } from "https://esm.sh/three@0.158.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://esm.sh/three@0.158.0/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "https://esm.sh/three@0.158.0/examples/jsm/postprocessing/UnrealBloomPass.js";
import { SMAAPass } from "https://esm.sh/three@0.158.0/examples/jsm/postprocessing/SMAAPass.js";

/* -----------------------------------------------------
   CONFIG
----------------------------------------------------- */
const CONFIG = {
  roomSizeFactor: 1.8,
  gridDivisions: 18,
  bloom: { strength: 0.9, radius: 0.6, threshold: 0.12 },
  colorFront: 0xC6FF4D,
  colorMid: 0x47F0C8,
  colorBack: 0x8BB236,
  damp: 0.06,
  scrollPower: 1.6
};

/* -----------------------------------------------------
   SCENE + CAMERA + RENDERER
----------------------------------------------------- */
const container = document.getElementById('container');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(Math.max(1, window.devicePixelRatio));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0f1316);

const camera = new THREE.PerspectiveCamera(
  55,
  window.innerWidth / window.innerHeight,
  0.1,
  10000
);

/* -----------------------------------------------------
   POSTPROCESSING
----------------------------------------------------- */
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  CONFIG.bloom.strength,
  CONFIG.bloom.radius,
  CONFIG.bloom.threshold
);
composer.addPass(bloomPass);
composer.addPass(new SMAAPass(window.innerWidth, window.innerHeight));

/* -----------------------------------------------------
   ROOM CREATION
----------------------------------------------------- */
let roomGroup = new THREE.Group();
scene.add(roomGroup);

// registry: every grid line → array of segments
const lineRegistry = [];

function buildRoom() {
  while (roomGroup.children.length) roomGroup.remove(roomGroup.children[0]);
  lineRegistry.length = 0;

  const minSide = Math.min(window.innerWidth, window.innerHeight);
  const s = minSide * CONFIG.roomSizeFactor;
  const div = CONFIG.gridDivisions;
  const step = s / div;

  function addGridPlane(origin, u, v, color) {
    const geom = new THREE.BufferGeometry();
    const verts = [];

    for (let i = 0; i <= div; i++) {
      const posU = -s / 2 + i * step;
      const a = origin.clone().addScaledVector(u, posU).addScaledVector(v, -s/2);
      const b = origin.clone().addScaledVector(u, posU).addScaledVector(v,  s/2);
      verts.push(a.x, a.y, a.z, b.x, b.y, b.z);
      lineRegistry.push([a.clone(), b.clone()]);
    }
    for (let j = 0; j <= div; j++) {
      const posV = -s / 2 + j * step;
      const a = origin.clone().addScaledVector(u, -s/2).addScaledVector(v, posV);
      const b = origin.clone().addScaledVector(u,  s/2).addScaledVector(v, posV);
      verts.push(a.x, a.y, a.z, b.x, b.y, b.z);
      lineRegistry.push([a.clone(), b.clone()]);
    }

    geom.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
    const mat = new THREE.LineBasicMaterial({
      color,
      transparent: true,
      opacity: 0.45,
      toneMapped: false
    });

    roomGroup.add(new THREE.LineSegments(geom, mat));
  }

  addGridPlane(new THREE.Vector3( 0, 0,  s/2), new THREE.Vector3(1,0,0), new THREE.Vector3(0,-1,0), CONFIG.colorFront);
  addGridPlane(new THREE.Vector3( 0, 0, -s/2), new THREE.Vector3(-1,0,0), new THREE.Vector3(0,-1,0), CONFIG.colorBack);
  addGridPlane(new THREE.Vector3(-s/2, 0, 0), new THREE.Vector3(0,0,1), new THREE.Vector3(0,-1,0), CONFIG.colorMid);
  addGridPlane(new THREE.Vector3( s/2, 0, 0), new THREE.Vector3(0,0,-1), new THREE.Vector3(0,-1,0), CONFIG.colorMid);
  addGridPlane(new THREE.Vector3(0, -s/2, 0), new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,1), CONFIG.colorMid);
  addGridPlane(new THREE.Vector3(0,  s/2, 0), new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,-1), CONFIG.colorBack);
}
function generateFaceGrid(faceGroup, size, divisions, baseColor) {
  const step = size / divisions;
  const half = size / 2;

  const material = new THREE.LineBasicMaterial({
    color: baseColor,
    transparent: true,
    opacity: 0.85,
    linewidth: 1
  });

  // Horizontal rows
  for (let y = -half; y <= half; y += step) {
    const geom = new THREE.BufferGeometry();
    const v = [];

    v.push(-half, y, 0);
    v.push(half, y, 0);

    geom.setAttribute("position", new THREE.Float32BufferAttribute(v, 3));
    const line = new THREE.Line(geom, material);

    faceGroup.add(line);
    lineRegistry.push(line); // <= REGISTRO REAL
  }

  // Vertical cols
  for (let x = -half; x <= half; x += step) {
    const geom = new THREE.BufferGeometry();
    const v = [];

    v.push(x, -half, 0);
    v.push(x, half, 0);

    geom.setAttribute("position", new THREE.Float32BufferAttribute(v, 3));
    const line = new THREE.Line(geom, material);

    faceGroup.add(line);
    lineRegistry.push(line); // <= REGISTRO REAL
  }
}

buildRoom();

/* -----------------------------------------------------
   TRON RUNNER + NEON TRAIL — COMPATIBLE lineRegistry
----------------------------------------------------- */
// 1) Material neón
const runnerMaterial = new THREE.MeshBasicMaterial({
  color: 0x7CFF5A,
  emissive: 0x55FF3A,
  emissiveIntensity: 1.4,
  transparent: true,
  opacity: 1.0,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
  toneMapped: false
});

// 2) Sphere
const runnerGeom = new THREE.SphereGeometry(8, 16, 16);
const runner = new THREE.Mesh(runnerGeom, runnerMaterial);
runner.visible = false;
runner.frustumCulled = false;
scene.add(runner);

// 3) Neon Trail
const TRAIL_POINTS = 50;
const trailGeom = new THREE.BufferGeometry();
trailGeom.setAttribute(
  "position",
  new THREE.Float32BufferAttribute(new Float32Array(TRAIL_POINTS * 3), 3)
);

const trailMaterial = new THREE.LineBasicMaterial({
  color: 0x7CFF5A,
  transparent: true,
  opacity: 0.9,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
  toneMapped: false
});

const trail = new THREE.Line(trailGeom, trailMaterial);
trail.visible = false;
trail.frustumCulled = false;
scene.add(trail);

// STATE
let runnerActive = false;
let runnerStart = null;
let runnerEnd = null;
let runnerT = 0;


// pick random line
function pickLine() {
  if (lineRegistry.length === 0) {
    console.warn("NO LINES AVAILABLE");
    return null;
  }
  return lineRegistry[Math.floor(Math.random() * lineRegistry.length)];
}


// update trail
function updateTrail() {
  const pos = trail.geometry.attributes.position.array;

  for (let i = (TRAIL_POINTS - 1) * 3; i >= 3; i--) {
    pos[i] = pos[i - 3];
  }

  pos[0] = runner.position.x;
  pos[1] = runner.position.y;
  pos[2] = runner.position.z;

  trail.geometry.attributes.position.needsUpdate = true;
}


// update runner
function updateRunner(dt) {
  if (!runnerActive) return;

  runnerT += dt * 0.8;

  if (runnerT >= 1) {
    runnerActive = false;
    runner.visible = false;
    trail.visible = false;
    return;
  }

  const pos = new THREE.Vector3().lerpVectors(runnerStart, runnerEnd, runnerT);
  runner.position.copy(pos);

  updateTrail();
}


// launch
function launchRunner() {
  if (runnerActive) return;

  const seg = pickLine();
  if (!seg) return;

  runnerStart = seg[0].clone();
  runnerEnd   = seg[1].clone();
  runnerT = 0;

  runner.visible = true;
  trail.visible = true;

  const arr = trailGeom.attributes.position.array;
  for (let i = 0; i < TRAIL_POINTS; i++) {
    arr[i * 3 + 0] = runnerStart.x;
    arr[i * 3 + 1] = runnerStart.y;
    arr[i * 3 + 2] = runnerStart.z;
  }
  trailGeom.attributes.position.needsUpdate = true;

  runnerActive = true;

  setTimeout(launchRunner, 3500 + Math.random() * 2000);
}

setTimeout(launchRunner, 18);

window.debugRunner = runner;





/* -----------------------------------------------------
   CAMERA ANIMATION 
----------------------------------------------------- */
let trackPos = 0, targetTrack = 0;
let scrollY = 0;
let docHeight = document.body.scrollHeight;

const track = {
  start: new THREE.Vector3(500, 100, 600),
  mid:   new THREE.Vector3(300, -60, 0),
  end:   new THREE.Vector3(-120, -120, -500)
};

const smoothStep = x => x*x*(3-2*x);

function sampleTrack(t) {
  if (t < 0.5) return new THREE.Vector3().lerpVectors(track.start, track.mid, smoothStep(t*2));
  return new THREE.Vector3().lerpVectors(track.mid, track.end, smoothStep((t-0.5)*2));
}

window.addEventListener('scroll', () => {
  scrollY = window.scrollY;
  docHeight = document.body.scrollHeight;
});

/* -----------------------------------------------------
   ANIMATE LOOP
----------------------------------------------------- */
let last = performance.now();
function animate(now) {
  const dt = (now-last)/1000;
  last = now;

  const vh = window.innerHeight;
  targetTrack = Math.min(1, scrollY / Math.max(1, docHeight - vh));
  trackPos += (targetTrack - trackPos) * CONFIG.damp;

  const camBase = sampleTrack(trackPos);
  camera.position.lerp(camBase, 0.05);

  camera.lookAt(0,0,0);

  // RUNNER UPDATE
  if (runnerActive) {
    runnerT += dt * 0.6; // speed
    if (runnerT >= 1) {
      runnerActive = false;
      runnerMaterial.opacity = 0;
    } else {
      const pos = new THREE.Vector3().lerpVectors(runnerStart, runnerEnd, runnerT);
      runner.position.copy(pos);
      runnerMaterial.opacity = 0.6 * (1 - runnerT);
    }
  }

  composer.render();
  requestAnimationFrame(animate);
  

}

animate();

/* resize */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
  buildRoom();
});


  </script>
</body>
</html>
